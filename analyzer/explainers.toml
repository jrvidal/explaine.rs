# Includes material from the Rust reference
# https://doc.rust-lang.org/reference/
# License:
# https://github.com/rust-lang/reference/blob/59c1c1dd4b0426c90a63415bdbc2f124755e72d2/LICENSE-MIT
# https://github.com/rust-lang/reference/blob/59c1c1dd4b0426c90a63415bdbc2f124755e72d2/LICENSE-APACHE


[help.AddBinOp]
title = "Addition Operator"
info = "The overloadable addition operator `+`."
std = "ops/trait.Add.html"

[help.SubBinOp]
title = "Substraction Operator"
info = "The overloadable substraction operator `-`."
std = "ops/trait.Sub.html"

[help.MulBinOp]
title = "Multiplication Operator"
info = "The overloadable multiplication operator `*`."
std = "ops/trait.Mul.html"

[help.DivBinOp]
title = "Division Operator"
info = "The overloadable division operator `/`."
std = "ops/trait.Div.html"

[help.RemBinOp]
title = "Remainder Operator"
info = "The overloadable remainder operator `%`."
std = "ops/trait.Rem.html"

[help.AndBinOp]
title = "Logical AND Operator"
info = "The logical AND operator `&&`."

[help.OrBinOp]
title = "Logical OR Operator"
info = "The logical OR operator `||`."

[help.BitXorBinOp]
title = "Bitwise XOR Operator"
info = "The overloadable bitwise XOR operator `^`."
std = "ops/trait.BitXor.html"

[help.BitAndBinOp]
title = "Bitwise AND Operator"
info = "The overloadable bitwise AND operator `&`."
std = "ops/trait.And.html"

[help.BitOrBinOp]
title = "Bitwise OR Operator"
info = "The overloadable bitwise OR operator `|`."
std = "ops/trait.Or.html"

[help.ShlBinOp]
title = "Left Shift Operator"
info = "The overloadable left shift operator `<<`."
std = "ops/trait.Shl.html"

[help.ShrBinOp]
title = "Right Shift Operator"
info = "The overloadable right shift operator `>>`."
std = "ops/trait.Shr.html"

[help.EqBinOp]
title = "Equality Operator"
info = "The overloadable equality operator `==`."
std = "cmp/trait.PartialEq.html"

[help.LtBinOp]
title = "Less-than Comparison Operator"
info = "The overloadable less-than comparison operator `<`."
std = "cmp/trait.PartialOrd.html"

[help.LeBinOp]
title = "Less-or-equal Comparison Operator"
info = "The overloadable less-or-equal comparison operator `<=`."
std = "cmp/trait.PartialOrd.html"

[help.NeBinOp]
title = "Not Equal Operator"
info = "The overloadable non-equality comparison operator `!=`."
std = "cmp/trait.PartialEq.html"

[help.GeBinOp]
title = "Greater-or-equal Comparison Operator"
info = "The overloadable greater-or-equal comparison operator `>=`."
std = "cmp/trait.PartialOrd.html"

[help.GtBinOp]
title = "Greater-than Comparison Operator"
info = "The overloadable greater-than comparison operator `>`."
std = "cmp/trait.PartialOrd.html"

[help.AddEqBinOp]
title = "Addition Assignment Operator"
info = "The overloadable addition assignment operator `+=`."
std = "ops/trait.AddAssign.html"

[help.SubEqBinOp]
title = "Substraction Assignment Operator"
info = "The overloadable substraction assignment operator `-=`."
std = "ops/trait.SubAssign.html"

[help.MulEqBinOp]
title = "Multiplication Assignment Operator"
info = "The overloadable multiplication assignment operator `*=`."
std = "ops/trait.MulAssign.html"

[help.DivEqBinOp]
title = "Division Assignment Operator"
info = "The overloadable division assignment operator `/=`."
std = "ops/trait.DivAssign.html"

[help.RemEqBinOp]
title = "Remainder Assignment Operator"
info = "The overloadable remainder assignment operator `%=`."
std = "ops/trait.RemAssign.html"

[help.BitXorEqBinOp]
title = "Bitwise XOR Assignment Operator"
info = "The overloadable bitwise XOR assignment operator `^=`."
std = "ops/trait.BitXorAssign.html"

[help.BitAndEqBinOp]
title = "Bitwise AND Assignment Operator"
info = "The overloadable bitwise AND assignment operator `&=`."
std = "ops/trait.BitAndAssign.html"

[help.BitOrEqBinOp]
title = "Bitwise OR Assignment Operator"
info = "The overloadable bitwise OR assignment operator `|=`."
std = "ops/trait.BitOrAssign.html"

[help.ShlEqBinOp]
title = "Left shift Assignment Operator"
info = "The overloadable left shift assignment operator `<<=`."
std = "ops/trait.ShlAssign.html"

[help.ShrEqBinOp]
title = "Left right Assignment Operator"
info = "The overloadable left right assignment operator `>>=`."
std = "ops/trait.ShrAssign.html"

[help.Binding]
title = "Associated Type Binding"
info = "This constraint specifies the actual type for the associated type `{ ident }` of this trait."
book = "ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types"

[help.ExprArray]
title = "Array Literal"
info = "A literal array, a sequence of elements with a known length at compile time."
std = "primitive.array.html"
book = "ch03-02-data-types.html#the-array-type"

[help.ExprArraySlice]
title = "Slice"
info = "A literal slice, a dynamically sized sequence of elements."
std = "primitive.slice.html"

[help.ExprAssign]
title = "Assignment"
info = "An assignment of a value to a variable or place."

[help.ExprAssignOp]
title = "Operation plus Assignment"
info = "An assignment of a computed value to a variable or place."

[help.ExprAsync]
title = "Async Block"
info = """An `async` block represents a delayed computation, much like the body of an async function or closure.

It produces a future that will run thorugh the block's statements once it is polled."""
keyword ="async"

[help.ExprAsyncMove]
title = "Moving Async Block"
info = "The `move` keyword instructs the compiler to capture variables in this async block by moving them, much like in the case of `move` closures."
keyword ="move"

[help.ExprAwait]
title = "`await` Expression"
info = "An `.await` expression suspends the computation of an `async` function until the awaited expression (a future) is ready."
keyword ="await"

[help.ExprBreak]
title = "`break`"
info = """A `break` expression terminates the
{{if label}}loop labeled by `{ label }`{{else}}innermost enclosing loop{{endif}}{{if expr}}
and specifies a final value for it{{endif}}."""
book = "ch03-05-control-flow.html"
keyword = "break"

[help.ExprClosure]
title = "Closure"
info = "A closure expression, an anonymous function that can capture environment variables."
book = "ch13-01-closures.html"

[help.ExprClosureMove]
title = "`move` Closure"
info = "The `move` keyword specifies that a closure should take ownership over the ambient variables it refers to in its body."
keyword = "move"
book = "ch13-01-closures.html"

[help.ExprClosureArguments]
title = "Closure arguments"
info = "Two vertical bars `| ··· |` enclose the list of arguments of a closure."
book = "ch13-01-closures.html"

[help.ExprClosureAsync]
title = "Async closure"
info = "An `async` closure (an [experimental feature](https://github.com/rust-lang/rust/issues/62290))."
keyword ="async"

[help.ExprClosureStatic]
title = "Static Closure"
info = "Static closures are an [experimental feature](https://github.com/rust-lang/rust/issues/43122)."
keyword = "static"

[help.ExprContinue]
title = "`continue` expression"
info = """A `continue` expression interrupts the current iteration of
{{if label}}the loop labeled by `{ label }`{{else}}the innermost enclosing loop{{endif}}
and resumes from its beginning."""
keyword = "continue"
book = "ch03-05-control-flow.html"

[help.ExprUnnamedField]
title = "Unnamed Field"
info = "This expression accesses an unnamed, indexed field of a tuple or a tuple struct."

[help.ExprForLoopToken]
title = "`for` - `in` loop"
info = "The `for` - `in` keywords indicate a loop over the values of an iterator."
keyword = "for"
book = "ch03-05-control-flow.html"

[help.ForLoopLocal-variable]
variant = "ForLoopLocal"
pattern = "ident: Some(..), .."
title = "`for` Loop Variable"
info = "Each element in the interator gets assigned to the `{ ident }` variable{{if mutability}}, which is mutable as if introduced with `let mut`{{endif}}."

[help.ForLoopLocal]
variant = "ForLoopLocal"
pattern = "ident: None, .."
title = "`for` Loop without Variable"
info = "By using the wildcard pattern `_`, this `for` loop iterates over every value of the iterator without actually using the values it yields."

[help.ExprIf]
title = "`if`"
info = "An `if` expression."
book = "ch03-05-control-flow.html"
keyword = "if"

[help.ExprIfLet]
title = "`if-let`"
info = "An `if-let` expression enters its body only if the given pattern matches."
book = "ch06-03-if-let.html"
keyword = "let"

[help.Else]
title = "`else`"
info = "`else` denotes the alternative branch of a `if` block, like in many other languages."
keyword = "else"
book = "ch03-05-control-flow.html"

[help.ExprIndex-simple]
variant = "ExprIndex"
pattern = "range: false"
title = "Index Expression"
info = "An index expression that might, for instance, access the element of a collection at a given index."
std = "ops/trait.Index.html"

[help.ExprIndex-range]
variant = "ExprIndex"
pattern = "range: true"
title = "Range Index Expression"
info = "A range index operation that might, for instance, return a sub-slice of the elements of a collection."
std = "ops/trait.Index.html"

[help.ExprLoopToken]
title = "Infinite loop"
info = "The `loop` keyword introduces an infinite loop."
keyword = "loop"
book = "ch03-05-control-flow.html"

[help.ExprMatchToken]
title = "`match` expression"
info = "A `match` expression enumerates a list of patterns to match against a given expression."
book = "ch06-02-match.html"
keyword = "match"

[help.ExprRangeHalfOpen]
title = "Half-open range"
info = "A half open range expression `(..)`, that generates a range of elements with an inclusive lower bound and an exclusive upper bound."

[help.ExprRangeClosed]
title = "Closed range"
info = "A closed range expression `(..=)`, that generates a range of elements with inclusive lower and upper bounds."

[help.ExprReference-immutable]
title = "Immutable reference"
variant = "ExprReference"
pattern = "mutable: false"
info = "An immutable (shared) borrow of another value."

[help.ExprReference-mutable]
title = "Mutable reference"
variant = "ExprReference"
info = "A mutable (exclusive) borrow of another value."
pattern = "mutable: true"

[help.ExprRepeat]
title = "Array Initialization"
info = "An expression that initializes an array of length `{ len }` by copying an initial value in every position."
book = "ch03-02-data-types.html#the-array-type"

[help.ExprReturn]
title = "`return` expression"
info = "This `return` keyword stops the execution of the current { of } with the provided value."
keyword = "return"

[help.ExprStruct]
title = "Struct Instantiation"
info = "An expression that builds an instance of a struct (or a struct variant of an enum) by listing the values of its fields."
book = "ch05-01-defining-structs.html#defining-and-instantiating-structs"

[help.ExprStructRest]
title = "Struct Update Syntax"
info = "A \"rest\" expression that copies the fields of a struct into another."
book = "ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax"

# TODO: contextualize to function/closure/async block?
[help.ExprTryQuestionMark]
title = "Question Mark Operator"
info = "The question mark operator `?` evaluates a fallible expression, and either unwraps a successful case or performs an early return for an unsuccessful case."
book = "ch09-02-recoverable-errors-with-result.html#propagating-errors"
std = "ops/trait.Try.html"

[help.ExprTryBlock]
title = "Try Block"
info = "`try` blocks are an [unstable feature](https://github.com/rust-lang/rust/issues/31436)."
std = "ops/trait.Try.html"

[help.ExprTuple]
title = "Tuple Expression"
info = "An expression that constructs a tuple.{{if single_comma}} The trailing comma helps disambiguate tuples of length 1.{{endif}}"
book = "ch03-02-data-types.html#the-tuple-type"

[help.ExprUnitTuple]
title = "Unit Expression"
info = "The `unit` value, a tuple without elements."
book = "ch03-02-data-types.html#the-tuple-type"
std = "primitive.unit.html"

[help.ExprType]
title = "Type Ascription"
info = "A type ascription expression, an [experimental feature](https://github.com/rust-lang/rust/issues/23416)."

[help.ExprUnsafe]
title = "Unsafe block"
info = "An `unsafe` block, that allows to dereference raw pointers and call `unsafe` functions, among other things."
keyword = "unsafe"

[help.ExprWhileLet]
title = "`while-let`"
info = "A `while let` loop continues its execution while the provided pattern matches."
keyword = "while"
book = "ch18-01-all-the-places-for-patterns.html#while-let-conditional-loops"

[help.ExprWhile]
title = "While loop"
info = "A `while` loop that iterates while its test condition is `true`."
keyword = "while"
book = "ch03-05-control-flow.html"

[help.ExprYield]
title = "Yield Expression"
info = "A `yield` expression, an [experimental feature](https://github.com/rust-lang/rust/issues/43122)."

[help.Macro]
title = "Macro Invocation"
info = "A macro is a special form that generates syntax at compile time. They are distinguished by the final bang (`!`) symbol."
book = "ch19-06-macros.html"

[help.MacroTokens]
title = "Macro Input"
info = "The input of a macro is a bunch of (almost) arbitrary tokens, and its interpretation depends on the particular macro."
book = "ch19-06-macros.html"

[help.Turbofish]
title = "Turbofish"
info = "The venerable [turbofish](https://turbo.fish/random) `::<>`. It is sometimes needed to specify generic arguments in paths to avoid ambiguity with the less than operator `<`."

[help.ParenthesizedGenericArguments]
title = "`Fn`-like Generic Arguments"
info = """For some traits, it's possible to specify their generic arguments as `Trait(A, B) -> C` instead of `Trait<A, B, Output=C>`.

In stable Rust, this is only possible for the `Fn*` traits.
"""
std = "ops/trait.Fn.html"

[help.PatBox]
title = "Box Pattern"
info = "A pattern that matches a `Box<..>`. This is an [experimental feature](https://doc.rust-lang.org/unstable-book/language-features/box-patterns.html)."

[help.PatIdent-value]
variant = "PatIdent"
pattern = "mutability: true, by_ref: false, .."
title = "Mutable Pattern Binding"
info = "The `{ ident }` binding this pattern introduces is mutable, as if introduced with a `let mut` declaration."

[help.PatIdent-ref]
variant = "PatIdent"
patterns = ["by_ref: true, ..", "by_ref: false, mutability: false, .."]
title = "By Ref Pattern"
info = """A by-reference pattern, that ensures that given the value that matches,
`{ ident }` is just a {{if mutability}}(mutable) {{endif}} borrow of it."""
keyword = "ref"

[help.PatIdentSubPat]
title = "`@` Binding"
info = "A pattern that matches the subpattern to the right of the `@` symbol, while simultaneously binding the value to `{ ident }`."
book = "ch18-03-pattern-syntax.html#-bindings"

[help.PatIdentMutableArg]
title = "Mutable Function Argument"
info = "A mutable function argument, that behaves as if `{ ident }` had been introduced by a `let mut`: it can be reassigned and mutable borrows can be taken."
keyword = "mut"

[help.PatOrLeading]
title = "Leading Pattern Separator"
info = "All patterns can be preceded by a leading `|` which has no further effect."

[help.PatOr]
title = "Pattern 'or' Operator"
info = "The `|` syntax allows to test several patterns in one case, from left to right."
book = "ch18-03-pattern-syntax.html#multiple-patterns"

[help.PatRange]
title = "Range Pattern"
info = "A {{if closed}}closed{{else}}half-open{{endif}} range pattern that matches any value within its bounds ({{if closed}}including{{else}}excluding{{endif}} the upper bound)."

[help.PatRest]
title = "Rest Pattern"
info = "The rest pattern `..`, which ignores the rest of the fields of this { of }."
book = "ch18-03-pattern-syntax.html#ignoring-remaining-parts-of-a-value-with-"

[help.PatStruct]
title = "Struct Pattern"
info = """A struct pattern {{if bindings}}that introduces bindings through destructuring{{else}}that matches struct values or struct enum variants.{{if emtpy}}

An struct pattern that ignores all its fields with `..` can even match non-struct enum variants.{{endif}}{{endif}}"""

[help.PatUnit]
title = "Unit Tuple Pattern"
info = "A pattern that only matches the unit value."
std = "primitive.unit.html"

[help.PatTuple]
title = "Tuple Pattern"
info = """A tuple pattern {{if bindings}}that introduces bindings through destructuring{{else}}that matches if the value is a tuple of the same length.{{endif}}{{if single_comma}}

The trailing comma helps disambiguate tuples of length 1.{{endif}}"""

[help.PatTupleStruct]
title = "Tuple Struct Pattern"
info = "A pattern {{if bindings}}that introduces bindings through destructuring{{else}}that matches if the value is of a particular tuple struct type (or enum tuple variant), and that can bind individual fields.{{endif}}"

[help.PatWild-normal]
title = "Wildcard Pattern"
info = "The wildcard pattern `_`, that matches any value and discards it."
book = "ch18-03-pattern-syntax.html#ignoring-an-entire-value-with-_"
variant = "PatWild"
pattern = "last_arm: false"

[help.PatWild-catchall]
title = "Wildcard Pattern"
info = "The wildcard pattern `_`, matches any value and discards it, and acts like a final \"catchall\" in this `match` expression."
book = "ch06-02-match.html#the-_-placeholder"
variant = "PatWild"
pattern = "last_arm: true"

[help.PathSegmentSelf]
title = "`self` Module"
info = "The `self` keyword refers to the current module."
keyword = "self"

[help.PathSegmentSuper]
title = "`super` Module"
info = "The `super` keyword represents the parent module."
keyword = "super"

[help.PathSegmentSelfType]
title = "Implementing Type"
info = "A reference to the implementing type of an implementation block or trait definition."
keyword = "Self"

[help.PathSegmentCrate]
title = "`crate` Root Module"
info = "A reference to the root module of the current crate."
keyword = "crate"

[help.QSelf]
title = "Explicit Self Type"
info = """This syntax allows to explicitly specify the type for which we access a method or another associated item."""

[help.QSelfAsTrait]
title = "Fully Qualified Syntax for Traits"
info = """This syntax allows to unambigously specify the trait for which we access a method or another associated item."""
keyword = "as"
book = "ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name"

[help.ReceiverPath]
title = "Method Receiver"
info = "The receiver of {{if method}}the `{ method }` method{{else}}this method call{{endif}}, like `this` in other languages."
keyword = "self"
book = "ch05-03-method-syntax.html"

[help.Attribute-other]
title = "Attribute"
variant = "Attribute"
pattern = ".."
info = """
Attributes assign metadata to expressions, statements and other elements.
{{if not outer}}

In particular, this is an _inner_ attribute (because it has the "bang" form:
`#![foo]` instead of `#[foo]`), which means it applies to the item that contains it.{{ endif }}
"""

[help.ItemExternCrate]
title = "`extern crate`"
info = "An `extern crate` declaration specifies a dependency on an external crate."
keyword = "extern"

[help.ItemFn]
title = "Function Declaration"
info = "A function declaration."

[help.ItemInlineMod]
title = "Inline `mod`"
info = "A module is a container for items. In this case they're defined inline together with its declaration."
keyword = "mod"
book = "ch07-02-defining-modules-to-control-scope-and-privacy.html"

[help.ItemExternMod]
title = "External `mod`"
info = "A module is a container for items. In this case the items are defined in a separated file."
keyword = "mod"
book = "ch07-02-defining-modules-to-control-scope-and-privacy.html"

[help.TraitItemMethod-method]
variant = "TraitItemMethod"
pattern = "of: FnOf::Method, .."
title = "Trait Method"
info = "A method declaration for the `{ trait_ }` trait{{if default}}, with a default implementation{{endif}}."
book = "ch10-02-traits.html"

[help.TraitItemMethod-fn]
variant = "TraitItemMethod"
pattern = "of: FnOf::AssociatedFunction, .."
title = "Trait Associated Function"
info = "An associated function declaration for the `{ trait_ }` trait{{if default}}, with a default implementation{{endif}}."
book = "ch10-02-traits.html"

[help.ImplItemMethod-method]
variant = "ImplItemMethod"
pattern = "of: FnOf::Method, trait_: None, .."
title = "Method Declaration"
info = "A method declaration for `{ self_ty }`."
book = "ch05-03-method-syntax.html"

[help.ImplItemMethod-method-trait]
variant = "ImplItemMethod"
pattern = "of: FnOf::Method, trait_: Some(..), .."
title = "Method Implementation"
info = "The implementation of a method from the `{ trait_ }` trait for `{ self_ty }`."
book = "ch05-03-method-syntax.html"

[help.ImplItemMethod-fn]
variant = "ImplItemMethod"
pattern = "of: FnOf::AssociatedFunction, trait_: None, .."
title = "Associated Function"
info = "An associated function declaration for `{ self_ty }`."
book = "ch05-03-method-syntax.html"

[help.ImplItemMethod-fn-trait]
variant = "ImplItemMethod"
pattern = "of: FnOf::AssociatedFunction, trait_: Some(..), .."
title = "Associated Function Implementation"
info = "The implementation of an associated function from the `{ trait_ }` trait for `{ self_ty }`."
book = "ch05-03-method-syntax.html"

[help.AsRename]
title = "Rename"
info = "The `as` keyword allows renames of imported items, for instance, to avoid conflict with locally defined items."
book = "ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#providing-new-names-with-the-as-keyword"

[help.AsRenameExternCrate]
title = "Rename"
info = "The `as` keyword allows renames of external crates."
keyword = "as"

[help.AsCast]
title = "Cast"
info = "The `as` keyword allows casting between certain types."
keyword = "as"

[help.AsyncFn]
title = "Async Function"
info = "An async function, whose signature is implicitly wrapped in `impl Future<..>`."
keyword ="async"

[help.ImplItemConst]
title = "Associated constant"
info = "An _associated constant_ that can be accessed as a nested item."
keyword = "const"

[help.TraitItemConst]
title = "Associated constant"
info = "An _associated constant_ that all implementing types can define."
keyword = "const"

[help.ItemConst]
title = "Constant"
info = "A _constant_ item is basically a value that gets inlined wherever it is used."
keyword = "const"

[help.ConstParam]
title = "`const` parameter"
info = """`{ name }` is a _const_ parameter of the generic `{ of_name }` { of }.
Const generics is an unstable feature that allows generalizing { of }s and other types of items based on concrete values."""
keyword = "const"

[help.ConstParamSimple]
title = "`const` parameter"
info = "A `const` generic parameter."
keyword = "const"

[help.ConstFn]
title = "`const` function"
info = "A `const` function can be used to compute constants at compile time."
keyword = "const"


[help.VisPublic]
title = "`pub` Visibility"
info = "This item is accessible and re-exportable from the parent module."
book = "ch07-02-defining-modules-to-control-scope-and-privacy.html"

[help.VisCrate]
title = "`crate` Visibility"
info = "This item is accessible and re-exportable from the parent module, but can only be used from within the current crate. This [experimental syntax](https://github.com/rust-lang/rust/issues/53120) is equivalent to `pub(crate)`."
keyword = "crate"

[help.VisRestricted-super]
variant = "VisRestricted"
pattern = "path: VisRestrictedPath::Super, .."
title = "Restricted Visibility"
info = "This item is accessible from the parent module, but cannot be re-exported.{{if in_}} It is equivalent to writing `pub(super)`.{{endif}}"
keyword = "pub"

[help.VisRestricted-crate]
variant = "VisRestricted"
pattern = "path: VisRestrictedPath::Crate, .."
title = "Restricted Visibility"
info = "This item is accessible and re-exportable from the parent module, but can only be used from within the current crate. {{if in_}} It is equivalent to writing `pub(super)`.{{endif}}"
keyword = "pub"

[help.VisRestricted-self]
variant = "VisRestricted"
pattern = "path: VisRestrictedPath::Self_, .."
title = "Restricted Visibility"
info = "This item is private, and cannot be accessed from the parent module. Writing {{if in_}}`pub(in self)` (equivalent to `pub(self)`){{else}}`pub(self)`{{endif}} has the same effect as not writing any privacy modifier at all."
keyword = "pub"

[help.VisRestricted-path]
variant = "VisRestricted"
pattern = "path: VisRestrictedPath::Path, .."
title = "Restricted Visibility"
info = "This item is only visible from the specified module and its descendants."
keyword = "pub"

[help.WhereClause]
title = "`where` Clause"
info = "A `where` clause that introduces additional constraints to the generic types of this item."
keyword = "where"

[help.Variant]
title = "Enum Variant"
info = "One of the _variants_ of the `{ name }` enum, {{if fields}}with associated data as { fields } fields{{else}}with no associated data{{endif}}."
book = "ch06-00-enums.html"

[help.VariantDiscriminant]
title = "Variant Discriminant"
info = "An explicit discriminant for the `{ name }` variant."
# TODO: reference

[help.ItemForeignModAbi]
title = "Extern Module"
info = "An `extern` declaration that introduces items that should be linked together with this program."
keyword = "extern"

[help.FnAbi]
title = "Function ABI"
info = "FnAbi"
keyword = "extern"

[help.BoundLifetimes]
title = "Higher-Rank Lifetime Bound"
info = "The `for` keyword indicates a generic bound over an infinite set of lifetimes."
keyword = "for"

[help.BoundLifetimesTraitBound]
title = "Higher-Rank Lifetime Bound"
info = """The `for<..>` construct indicates that the trait bound `{ ty }` is in fact an _infinite_ collection of
bounds, for every value of `{ lifetime }`{{if multiple}} and the rest of the lifetimes within `<..>`{{endif}}."""
keyword = "for"

[help.BoundLifetimesBareFnType]
title = "Higher-Rank Lifetime in Function Type"
info = """The `for<..>` construct indicates that the given function type `fn(...)` is in fact an _infinite_ collection of
type bounds."""
keyword = "for"

[help.ItemImpl-intrinsic]
title = "Implementation Block"
info = "An `impl` block that declares _intrinsic_ methods and other items for a given type."
book = "ch05-03-method-syntax.html"
keyword = "impl"
variant = "ItemImpl"
pattern = "trait_: false, .."

[help.ItemImpl-trait]
title = "Trait Implementation Block"
info = """{{if negative}}A negative{{else}}An{{endif}} `impl` block that
{{if negative}}asserts that a trait is not implemented{{else}}implements a trait{{endif}} for a given type.{{if negative}}

Negative implementations are an [experimental feature](https://github.com/rust-lang/rust/issues/13231).{{endif}}"""
keyword = "impl"
variant = "ItemImpl"
pattern = "trait_: true, .."

[help.ItemImplForTrait]
title = "Trait implementation"
info = "The `for` keyword indicates the type for which a trait is being implemented."
keyword = "for"
book = "ch10-02-traits.html"

[help.ItemMacroRules]
title = "Declarative Macro"
info = "A declarative macro or _macro by example_ declaration that introduces the `{ name }!` macro."
book = "ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming"

[help.TypeImplTrait]
title = "`impl Trait` return type"
info = "The `impl` keyword represents an anonymous (but fixed) type that implements the specified trait."
book = "ch10-02-traits.html#returning-types-that-implement-traits"
keyword = "impl"

[help.Local-immutable]
title = "Variable Binding"
info = "A `let` statement that introduces {{if ident}}the `{ ident }` local variable{{else}}one or more local variables{{endif}}."
keyword = "let"
book = "ch02-00-guessing-game-tutorial.html#storing-values-with-variables"
variant = "Local"
pattern = "mutability: false, .."

[help.Local-mutable]
title = "Mutable Variable Binding"
info = "A `let mut` statement that introduces the _mutable_ local variable `{ ident }`, which can be reassigned and for which mutable borrows can be taken."
keyword = "mut"
book = "ch03-01-variables-and-mutability.html"
variant = "Local"
pattern = "mutability: true, .."

[help.Label-stable]
title = "Loop Label"
info = """A label for the adjacent `{ loop_of }` expression

It enables `break` and `continue` expressions to specify the particular loop they affect
(instead of simply the innermost enclosing one)."""
variant = "Label"
patterns = ["loop_of: LoopOf::While", "loop_of: LoopOf::WhileLet", "loop_of: LoopOf::For", "loop_of: LoopOf::Loop"]

[help.Label-unstable]
title = "Block Label"
info = "Block labels are an [unstable feature](https://github.com/rust-lang/rust/issues/48594)."
variant = "Label"
pattern = "loop_of: LoopOf::Block"

[help.True]
title = "`true` boolean value"
info = "The `true` boolean value."
keyword = "true"
std = "primitive.bool.html"

[help.False]
title = "`false` boolean value"
info = "The `false` boolean value."
keyword = "false"
std = "primitive.bool.html"

[help.LitChar]
title = "Character Literal"
info = "A character literal of type `char`."
std = "primitive.char.html"

[help.LitByte]
title = "Byte Literal"
info = "A byte literal of type `u8`."

[help.LitByteStr]
title = "Byte String Literal"
info = """A literal string with a leading `b` is a _byte literal string_, of type `&'static [u8]`.{{if raw}}

This is a _raw_ byte string literal (given its `r{ prefix }` prefix) that does not process escapes{{if prefix}}
and which needs to be closed by a matching number of `#` symbols{{endif}}.{{endif}}"""
# reference/tokens.html#byte-string-literals

[help.LitFloat]
title = "Floating-point Literal"
info = """A floating-point number literal{{if suffix}} of type `{ suffix }` (explicited by its suffix){{endif}}.{{if separators}}

The underscores `_` are merely for readability reasons.{{endif}}"""

[help.LitInt]
title = "Integer Literal"
info = """An integer literal{{if suffix}} of type `{ suffix }` (explicited by its suffix){{endif}}{{if mode}},
in { mode } notation (as indicated by the `{ prefix }` prefix){{endif}}.{{if separators}}

The underscores `_` are merely for readability reasons.{{endif}}"""

[help.LitStr]
title = "String Literal"
info = """A literal string, of type `&'static str`.{{if raw}}

This is a _raw_ string literal (given its `r{ prefix }` prefix) that does not process escapes{{if prefix}}
and which needs to be closed by a matching number of `#` symbols{{endif}}.{{endif}}"""

[help.ArmIfGuard]
title = "`if` guard"
info = """The `if` keyword can be used to introduce _match guards_, that add extra conditions to a case
within a `match` expression before matching."""
book = "ch18-03-pattern-syntax.html#extra-conditionals-with-match-guards"
keyword = "if"

[help.MutSelf]
title = "Mutably borrowed `self`"
info = """This method takes `self` as a mutable (exclusive) reference.{{if explicit}}

This syntax is the longer version of the more usual "`&mut self`".{{if mutability}} The `mut` modifier makes the `self` _binding_
mutable, so it can be reassigned.{{endif}}{{endif}}"""
book = "ch05-03-method-syntax.html"
keyword = "self"

[help.ValueSelf]
title = "Owned `self`"
info = """This method consumes `self` as a value.{{if mutability}}
Since it is marked as `mut`, it can also be mutated like a variable introduced by `let mut`.{{endif}}{{if explicit}}

This syntax annotates the `self` type explicitly, which is usually shortened to simply "`self`".{{endif}}"""
book = "ch05-03-method-syntax.html"
keyword = "self"

[help.RefSelf]
title = "Borrowed `self`"
info = """This method takes an immutable (shared) reference to `self`.{{if explicit}}

This syntax is the longer version of the more usual "`&self`".{{if mutability}} The `mut` modifier makes the `self` _binding_
(not the value) mutable, so it can be reassigned.{{endif}}{{endif}}"""
book = "ch05-03-method-syntax.html"
keyword = "self"

[help.SpecialSelf]
title = "Special `self`"
info = "This method consumes a special `Self` type.{{if mutability}} The `mut` modifier allows mutation, as if introduced by `let mut`.{{endif}}"
keyword = "Self"

[help.PathLeadingColon]
title = "Referencing External Crates"
info = "A leading `::` in a path means that the path refers to an external crate."

[help.StaticMut]
title = "Mutable Static"
info = "A `static mut` item is a value that is embedded in the memory of the final executable _and_ that can be mutated (though it is highly unsafe to do so)."

[help.Static]
title = "Static Item"
info = "A `static` item is a value that is embedded in the memory of the final executable."
keyword = "static"

[help.TypeReference-immutable]
title = "Immutable Reference Type"
info = "The type of an immutable (shared) borrow over a value of type `{ ty }`."
variant = "TypeReference"
pattern = "mutable: false, .."

[help.TypeReference-mutable]
title = "Mutable Reference Type"
info = "The type of a mutable (exclusive) borrow over a value of type `{ ty }`."
variant = "TypeReference"
pattern = "mutable: true, .."

[help.TypeSlice]
title = "Slice Type"
info = "The type of a slice{{if dynamic}} reference{{endif}} of elements of type `{ ty }`."
std = "primitive.slice.html"

[help.TypeTraitObject]
title = "Trait Object Type"
info = """The type of a _trait object_, an _unsized_ type that implements the trait `{ ty }` {{if multiple}}(and some others) {{endif}}through dynamic dispatch.
{{if lifetime}}This trait object also has a lifetime bound `{ lifetime }`.{{endif}}
{{if not dyn_}}

A trait object is usually marked with the `dyn` keyword.{{endif}}
"""
keyword = "dyn"
book = "ch17-02-trait-objects.html"

[help.UseGlob]
title = "Glob Operator"
info = "The glob operator `*` will bring all public items of a given module into scope."
book = "ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#the-glob-operator"

[help.UseGroup]
title = "Group Import"
info = "A group of several items imported from `{ parent }`, grouped together in a single import."

[help.UseGroupSelf]
title = "Self Module Import"
info = "A reference to the parent `{ parent }` module so it is brought to scope."
keyword = "self"
book = "ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#using-nested-paths-to-clean-up-large-use-lists"

[help.ForeignItemType]
title = "`extern` Type"
info = "Extern types are an [experimental feature](https://github.com/rust-lang/rust/issues/43467)."
keyword = "type"

[help.RawIdent]
title = "Raw Identifier"
info = "A raw identifier (as indicated by the `r#` prefix), that allows using keywords (like `match` or `dyn`) as variable names, field names, etc."

[help.ImplItemType]
title = "Associated Type"
info = "The `type` keyword specifies an associated type for the implementing type."
keyword = "type"
book = "ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types"

[help.ItemUnsafeImpl]
title = "Unsafe Trait Implementation"
info = "An `unsafe` trait implementation must be marked as such when the trait being implemented is `unsafe`."
keyword = "unsafe"

[help.ItemEnum]
title = "`enum` Declaration"
info = """The declaration for {{if generic}}a generic {{else}}an {{endif}}`enum`, a data type specified through a list of variants.
{{if empty}}

This is an _empty enum_ without variants, which constitutes an [empty type](https://doc.rust-lang.org/nomicon/exotic-sizes.html#empty-types)
which cannot be instantiated.
{{endif}}"""
keyword = "enum"
book = "ch06-00-enums.html"

[help.ItemStruct]
title = "`struct` Declaration"
info = """The declaration for a {{if generic}}generic {{endif}}`struct`, a data type{{if unit}} (usually){{endif}} defined by a list of fields.{{if unit}}

In this case, `{ name }` is a _unit_ struct, with no fields.{{endif}}"""
keyword = "struct"
book = "ch05-01-defining-structs.html"
pattern = ".."

[help.ItemAutoTrait]
title = "Auto Trait"
info = "`auto` traits are automatically implemented by the compiler in a structural fashion. `auto` traits are an unstable feature."
# TODO: nomicon

[help.ItemUnsafeTrait]
title = "Unsafe trait"
info = """An `unsafe` trait is one for which there are extra guarantees that must be uphold before implementing it
for a given type, and such that those guarantees cannot be ensured by the compiler."""
keyword ="unsafe"

[help.ItemTrait]
title = "Trait Declaration"
info = "The declaration for a {{if generic}}generic {{endif}}trait, that defines behavior for each type that implements it."
keyword = "trait"
book = "ch10-02-traits.html"

[help.ItemTraitSupertraits]
title = "Supertraits"
info = "A list of supertraits that all implementors of this trait must also implement."
book = "ch19-03-advanced-traits.html#using-supertraits-to-require-one-traits-functionality-within-another-trait"

[help.ItemType]
title = "Type Alias"
info = "A type alias works as a synonym of the aliased type."
keyword = "type"
book = "ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types"

[help.ItemUnion]
title = "Union"
info = "A `union` is an \"unsafe enum\", that allows interoperation with C enums. Reading fields from a union is unsafe."
keyword = "union"

[help.ItemUse]
title = "`use` Item"
info = "A `use` declaration acts like a shortcut by shortening the path to the item in a module."
book = "ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"
keyword = "use"

[help.UnsafeFn]
title = "Unsafe function"
info = "An `unsafe` function might contain unsafe operations within its body, as if all its statements where surrounded in an `unsafe` block."
keyword = "unsafe"

[help.TraitBoundModifierQuestion-sized]
title = "`?Sized` Trait Bound"
info = "A bound that expresses that the `Sized` trait may not be implemented for a given type parameter."
variant = "TraitBoundModifierQuestion"
book = "ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait"
pattern = "sized: true"

[help.TraitBoundModifierQuestion-other]
title = "Implicit Bound"
info = """The `?` modifier in a trait bound indicates that the trait is an _implicit bound_ in every type parameter,
except when marked with this modifier. It is currently only valid for the `Sized` trait."""
variant = "TraitBoundModifierQuestion"
pattern = "sized: false"

[help.TraitItemType]
title = "Associated Type"
info = "The `type` keyword introduces an _associated type_ that implementors can specify."
keyword = "type"
book = "ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types"

[help.TypeArray]
title = "Array Type"
info = "The type of an array, a sequence of elements with a length that is known at compile-time."
book = "ch03-02-data-types.html#the-array-type"
std = "primitive.array.html"

[help.TypeInfer]
title = "Inferred Type"
info = "The `_` type is a placeholder that requests the compiler to try to infer what the correct type should go in there."
book = "ch08-03-hash-maps.html#creating-a-new-hash-map"

[help.TypeNever]
title = "Never Type"
info = "The type `!` represents computations that never resolve to any value at all."
std = "primitive.never.html"

[help.TypeParam]
title = "Type Parameter"
info = """`{ name }` is a type parameter of the `{ of_name }` { of }, which is _generic_.
It can be _instantiated_ for different types taking the place of `{ name }`."""
book = "ch10-01-syntax.html"

[help.TypeParamUse]
title = "Type Parameter"
info = """This is a type param usage!"""
# TODO(generics)

[help.TypeParamBoundAdd]
title = "Trait Bounds"
info = "The plus sign `+` joins several bounds that a given type must fulfill."

[help.TypeTuple]
title = "Tuple Type"
info = "The type of a _tuple_, an heterogeneous, finite list of types.{{if single_comma}} The trailing comma helps disambiguate tuples of length 1.{{endif}}"
book = "ch03-02-data-types.html#the-tuple-type"

[help.TypeTupleUnit]
title = "Unit Type"
info = "The `unit` type, a tuple without elements."
book = "ch03-02-data-types.html#the-tuple-type"
std = "primitive.unit.html"

[help.KnownTypeU8]
title = "`u8` Type"
info = "The `u8` primitive type."
std = "primitive.u8.html"

[help.KnownTypeU16]
title = "`u16` Type"
info = "The `u16` primitive type."
std = "primitive.u16.html"

[help.KnownTypeU32]
title = "`u32` Type"
info = "The `u32` primitive type."
std = "primitive.u32.html"

[help.KnownTypeU64]
title = "`u64` Type"
info = "The `u64` primitive type."
std = "primitive.u64.html"

[help.KnownTypeU128]
title = "`u128` Type"
info = "The `u128` primitive type."
std = "primitive.u128.html"

[help.KnownTypeUSize]
title = "`usize` Type"
info = "The `usize` primitive type."
std = "primitive.usize.html"

[help.KnownTypeI8]
title = "`i8` Type"
info = "The `i8` primitive type."
std = "primitive.i8.html"

[help.KnownTypeI16]
title = "`i16` Type"
info = "The `i16` primitive type."
std = "primitive.i16.html"

[help.KnownTypeI32]
title = "`i32` Type"
info = "The `i32` primitive type."
std = "primitive.i32.html"

[help.KnownTypeI64]
title = "`i64` Type"
info = "The `i64` primitive type."
std = "primitive.i64.html"

[help.KnownTypeI128]
title = "`i128` Type"
info = "The `i128` primitive type."
std = "primitive.i128.html"

[help.KnownTypeISize]
title = "`isize` Type"
info = "The `isize` primitive type."
std = "primitive.isize.html"

[help.KnownTypeChar]
title = "`char` Type"
info = "The `char` primitive type."
std = "primitive.char.html"

[help.KnownTypeBool]
title = "`bool` Type"
info = "The `bool` primitive type."
std = "primitive.bool.html"

[help.KnownTypeF32]
title = "`f32` Type"
info = "The `f32` primitive type."
std = "primitive.f32.html"

[help.KnownTypeF64]
title = "`f64` Type"
info = "The `f64` primitive type."
std = "primitive.f64.html"

[help.KnownTypeStr]
title = "`str` Type"
info = "The `str` primitive type."
std = "primitive.str.html"

[help.KnownTypeStrSlice]
title = "`&str` Type"
info = "The type of a{{if mutability}} mutable{{endif}} string slice."
std = "primitive.str.html"

[help.TypeConstPtr]
title = "Raw Pointer"
info = "A `const` pointer is a raw pointer without the safety guarantees of the borrow checker."
keyword = "const"
book = "ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer"

[help.TypeMutPtr]
title = "Mutable Raw Pointer"
info = "A `mut` pointer is a mutable, raw pointer without the safety guarantees of the borrow checker."
keyword = "mut"
book = "ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer"

[help.TypeBareFn]
title = "Function Pointer Type"
info = "The type of a function pointer, a reference to a free-standing function or method."
keyword = "fn"
std = "primitive.fn.html"

[help.TypeBareUnsafeFn]
title = "Unsafe Function Pointer Type"
info = "A modifier of a function pointer type that indicates that the function/method is unsafe."
keyword = "unsafe"
std = "primitive.fn.html"

[help.TypeBareFnAbi]
title = "Function Pointer Type ABI"
info = "An ABI that the functions of this type must have."
keyword = "extern"
std = "primitive.fn.html"

[help.ItemTraitAlias]
title = "Trait Alias"
info = "A trait alias, an [experimental feature](https://github.com/rust-lang/rust/issues/41517)."
keyword = "trait"

[help.Field-named]
variant = "Field"
title = "Named Field"
info = "The field `{name}` in the `{ of_name }` { of }."
pattern = "name: Some(..), .."

[help.Field-unnamed]
variant = "Field"
title = "Unnamed Field"
info = "An unnamed field in the `{ of_name }` { of }."
pattern = "name: None, .."

[help.FieldPatUnnamed]
title = "Tuple Struct Explicit Field Pattern"
info = "This is a pattern for a _tuple_ struct, where instead of positional patterns, explicit indices are being used."

[help.FieldPatShorthand]
title = "Field Pattern Shorthand"
info = "Shorthand pattern equivalent to `{ ident }: { ident }`."

[help.FieldValueShorthand]
title = "Field Init Shorthand"
info = "Shorthand expression equivalent to `{ name }: { name }`."

[help.FieldUnnamedValue]
title = "Unnamed Field Value"
info = "The unnamed fields of this tuple struct (or tuple enum variant) are being initialized explicitly by specifying their indices."

[help.Shebang]
title = "Shebang"
info = "The Rust compiler accepts a shebang in source files, but ignores it."
# TODO: reference

[help.FatArrow]
title = "Fat Arrow"
info = "Each branch of a `match` expression has a fat arrow `=>` that links a pattern on the left with an expression to be evaluated on the right when said pattern is a match."

# TODO: distinguish between /// and #[doc(...)]

[help.DocBlock-outer]
variant = "DocBlock"
title = "Doc comments"
info = "Comments that start with three slashes (`///`) are _doc comments_, and they generate documentation."
pattern = "outer: true"
book = "ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments"

[help.DocBlock-inner]
variant = "DocBlock"
title = "Doc comments"
info = "Comments that start with `//!` are _inner doc comments_, and they generate documentation for the item that contains them."
pattern = "outer: false"
book = "ch14-02-publishing-to-crates-io.html#commenting-contained-items"

[help.RArrow]
title = "Right Arrow `->`"
info = "A right arrow token `->` used to signify the return type of this { return_of }."

[help.StaticLifetime]
title = "`'static` lifetime"
info = "The `'static` lifetime is a special, constant lifetime that represents a value that can potentially live indefinitely."
book = "ch10-03-lifetime-syntax.html#the-static-lifetime"

[help.LifetimeParam]
title = "Lifetime generic parameter"
info = """`'{ name }` is a generic lifetime parameter of the `{ of_name }` { of }.
A generic lifetime parameter indicates that this { of } is subject to the borrow checker."""
# TODO

[help.Comment-block]
title = "Block Comment"
variant = "Comment"
pattern = "block: true"
info = "A block comment."

[help.Comment-line]
title = "Line Comment"
variant = "Comment"
pattern = "block: false"
info = "A line comment."
